<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>I AM WHERE</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #0d0d0d;
      font-family: monospace;
      color: white;
    }

    #startButton {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px 50px;
      font-size: 26px;
      background: none;
      border: 2px solid white;
      color: white;
      cursor: pointer;
      z-index: 10;
      transition: opacity 1s ease, transform 0.5s ease, box-shadow 0.5s ease;
      animation: pulse 3s infinite;
    }

    #startButton:hover {
      background: white;
      color: black;
      transform: translate(-50%, -50%) scale(1.05);
      box-shadow: 0 0 15px white;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 5px white; }
      50% { box-shadow: 0 0 25px white; }
      100% { box-shadow: 0 0 5px white; }
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      display: block;
    }
  </style>
</head>
<body>
  <button id="startButton">AWAKEN YOURSELF</button>

  <!-- Load p5.js -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.4.2/lib/p5.min.js"></script>

  <!-- Audio -->
  <!-- Make sure these audio files exist in the same directory or provide correct paths -->
  <audio id="voice1" src="voice1.mp3" preload="auto"></audio>
  <audio id="voice2" src="voice2.mp3" preload="auto"></audio>
  <audio id="voice3" src="voice3.mp3" preload="auto"></audio>
  <audio id="om" src="om.mp3" preload="auto"></audio>

  <script>
    let nodes = [];
    let firingSequence = [];
    let firingIndex = 0;
    let message = "";
    let messages = ["I AM", "WHERE?", "A NETWORK NOT AN INDIVIDUAL"];
    let messageCount = 0;
    let messageTimer = 0; // Time when the current message appeared
    let firing = false;
    let ready = true;
    let button;
    let fireStartTime = 0;
    let initiationStarted = false;
    let omStarted = false;
    let scaleFactor = 1;

    // Specific state for the third message fade
    let thirdMessageFadeStartTime = 0;
    let thirdMessageAlpha = 255;
    const thirdMessageAppearDelay = 3000; // Time message stays fully visible
    const thirdMessageFadeDuration = 3000; // How long the fade takes

    // State for silence delay before button reappears
    let waitingForSilence = false;
    let silenceStartTime = 0;
    const silenceDuration = 2000; // Wait 2 seconds after fade before button

    function setup() {
      createCanvas(windowWidth, windowHeight);

      let screenW = displayWidth / pixelDensity();
      let screenH = displayHeight / pixelDensity();
      let isSmallScreen = screenW < 700 || screenH < 600;
      scaleFactor = isSmallScreen ? 1.5 : 1;
      for (let i = 0; i < 250; i++) {
        nodes.push({
          pos: createVector(random(width), random(height)),
          vel: createVector(random(-0.3, 0.3), random(-0.3, 0.3)),
          active: false,
          lastFired: 0
        });
      }

      button = document.getElementById("startButton");

      // --- Button Click Handler with Audio Unlock ---
      button.addEventListener("click", () => {
        if (ready && !initiationStarted) {
          initiationStarted = true;

          // --- TRY TO UNLOCK AUDIO CONTEXT ---
          // This attempts to play a sound immediately in response to user interaction,
          // which is often required by mobile browsers/WebViews to allow subsequent plays.
          try {
            const voice1 = document.getElementById('voice1');
             // Check if audio element exists and is currently paused
            if (voice1 && voice1.paused) {
               // Attempt to play. This might return a Promise.
               let playPromise = voice1.play();
               if (playPromise !== undefined) {
                 playPromise.then(() => {
                     // Once playback starts (even for a moment), pause it.
                     voice1.pause();
                     console.log("Audio context likely unlocked by initial play/pause.");
                 }).catch(error => {
                     // Handle errors, especially 'NotAllowedError' which indicates policy issues.
                     if (error.name === 'NotAllowedError') {
                         console.warn("Audio unlock failed: Autoplay policy blocked initial play. Sound might not work.");
                     } else {
                         console.error("Audio unlock error:", error);
                     }
                     // Proceed even if unlocking fails, as behavior varies across browsers.
                 });
               }
            } else if (!voice1) {
                 console.warn("Audio unlock attempt skipped: #voice1 element not found.");
            }
          } catch (e) {
             // Catch any synchronous errors during the attempt.
             console.error("Exception during audio unlock attempt:", e);
          }
          // --- END AUDIO UNLOCK ATTEMPT ---


          fadeOutButton(); // Start fading out the button visually

          // Sequence timing starts after button click and unlock attempt
          setTimeout(() => {
            playOm(); // Play Om sound after 3 seconds
            setTimeout(() => {
              // Start message sequence after another 3 seconds
              messageCount = 0;
              waitingForSilence = false; // Reset silence state
              silenceStartTime = 0;
              triggerNextMessage();
            }, 3000); // Delay before first message
          }, 3000); // Delay before Om sound
        }
      }); // End of button click listener
    } // End of setup()

function draw() {
  background(13); // Dark background

  // --- Update and draw nodes & connections ---
  for (let node of nodes) {
    node.pos.add(node.vel);
    // Bounce nodes off edges
    if (node.pos.x < 0 || node.pos.x > width) node.vel.x *= -1;
    if (node.pos.y < 0 || node.pos.y > height) node.vel.y *= -1;
  }

  // Draw connections between close nodes
  for (let i = 0; i < nodes.length; i++) {
    for (let j = i + 1; j < nodes.length; j++) {
      let d = dist(nodes[i].pos.x, nodes[i].pos.y, nodes[j].pos.x, nodes[j].pos.y);
      if (d < 90) { // Only draw lines if nodes are close enough
        stroke(100, 150, 255, map(d, 0, 90, 180, 0)); // Line fades with distance
        strokeWeight(map(d, 0, 90, 1.5, 0.1)); // Line gets thinner with distance
        line(nodes[i].pos.x, nodes[i].pos.y, nodes[j].pos.x, nodes[j].pos.y);
      }
    }
  }

  // --- Handle node firing animation ---
  if (firing && firingIndex < firingSequence.length) {
    // Activate next node in sequence at intervals
    if (millis() - fireStartTime > 40) {
      let currentNodeIndex = firingSequence[firingIndex];
       // Check if index is valid before accessing node
      if(currentNodeIndex >= 0 && currentNodeIndex < nodes.length) {
        nodes[currentNodeIndex].active = true;
        nodes[currentNodeIndex].lastFired = millis();
      }
      firingIndex++;
      fireStartTime = millis(); // Reset timer for next step
    }
  }
  // Deactivate nodes after a short time
  for (let node of nodes) {
    if (node.active && millis() - node.lastFired > 400) {
      node.active = false;
    }
  }
  // Draw nodes (active nodes are brighter/larger)
  noStroke();
  for (let node of nodes) {
    if (node.active) {
      fill(255, 255, 150); // Bright yellow for active
      ellipse(node.pos.x, node.pos.y, 10 * scaleFactor, 10 * scaleFactor);
    } else {
      fill(180, 200, 255); // Pale blue for inactive
      ellipse(node.pos.x, node.pos.y, 4 * scaleFactor, 4 * scaleFactor);
    }
  }

  // --- Message Display and Fading Logic ---
  if (message !== "") {
    textAlign(CENTER, CENTER);
    let ts = 42 * scaleFactor; // Base text size
    ts = constrain(ts, 24, 42); // Limit text size
    textSize(ts);

    let currentAlpha = 255; // Default alpha is fully opaque

    // --- Special Fading Logic for the Third Message ---
    if (messageCount === 2 && message === "A NETWORK NOT AN INDIVIDUAL") {
      let timeSinceAppeared = millis() - messageTimer;

      // Check if it's time to start fading
      if (timeSinceAppeared > thirdMessageAppearDelay) {
        // Only set the fade start time once when the delay is passed
        if (thirdMessageFadeStartTime === 0) {
           thirdMessageFadeStartTime = millis();
        }
        // Calculate time elapsed since fade started
        let fadeElapsed = millis() - thirdMessageFadeStartTime;
        // Map elapsed fade time to alpha value (255 down to 0)
        currentAlpha = map(fadeElapsed, 0, thirdMessageFadeDuration, 255, 0);
        currentAlpha = constrain(currentAlpha, 0, 255); // Ensure alpha stays within 0-255
      } else {
        // Before fading starts, keep alpha at 255 and ensure fade timer is reset
        currentAlpha = 255;
        thirdMessageFadeStartTime = 0;
      }
      thirdMessageAlpha = currentAlpha; // Store the calculated alpha for logic checks

      // Draw the third message (two lines) only if it's still visible
      if (thirdMessageAlpha > 0) {
          fill(255, 255, 255, thirdMessageAlpha); // Use calculated alpha
          text("A NETWORK", width / 2, height / 2 - ts * 0.6);
          text("NOT AN INDIVIDUAL", width / 2, height / 2 + ts * 0.6);
      }

    } else {
      // --- Normal Display for Other Messages ---
      fill(255, 255, 255, 255); // Fully opaque white
      text(message, width / 2, height / 2);
    }
  } // End of message display block

  // --- Logic to Advance Message or Start Silence Period ---
  // Check if node firing animation for the current message is complete
  // AND we are not already in the silence waiting period
  if (firing && firingIndex >= firingSequence.length && !waitingForSilence) {

    if (messageCount < messages.length - 1) { // If it's NOT the last message
        // Wait a bit after the message appeared before switching to the next
        // (This prevents messages changing too rapidly)
        if (millis() - messageTimer > 2000) { // e.g., 2 seconds minimum display time
           messageCount++;
           triggerNextMessage();
        }
    } else if (messageCount === messages.length - 1) { // If it IS the last message
        // Check if the last message has completely faded out
        if (thirdMessageAlpha <= 0) {
            // --- Start the Silence Period ---
            waitingForSilence = true; // Set flag to indicate silence period has begun
            silenceStartTime = millis(); // Record the time silence starts
            message = ""; // Clear the message variable so nothing is drawn
            firing = false; // Stop node firing updates during silence
        }
        // Otherwise (still fading), do nothing and let the fade continue in the next draw() frame
    }
  }

  // --- Check Silence Timer and Trigger End Sequence ---
  if (waitingForSilence) {
      let silenceElapsed = millis() - silenceStartTime;
      // Check if the required silence duration has passed
      if (silenceElapsed >= silenceDuration) {
          endSequence(); // Call endSequence to reset and show button
      }
  }
} // End of draw()

    // --- Utility Functions ---

    function fadeOutButton() {
      ready = false; // Prevent further clicks during fade/sequence
      button.style.transition = "opacity 1s ease"; // CSS transition for smooth fade
      button.style.opacity = 0;
      // Use setTimeout to set display:none *after* fade, preventing layout shifts
      setTimeout(() => {
        button.style.display = "none";
      }, 1000); // Match transition duration
    }

    function fadeInButton() {
      button.style.display = "block"; // Make button visible again in layout
      // Use a tiny delay before changing opacity to ensure 'display' change is rendered
      setTimeout(() => {
        button.style.opacity = 1; // Fade in using CSS transition
        initiationStarted = false; // Allow sequence to be restarted
        ready = true; // Make button clickable again
      }, 50); // Small delay (50ms)
    }

    function triggerNextMessage() {
      message = messages[messageCount]; // Get the message text
      playAudio(messageCount); // Play the corresponding voice
      messageTimer = millis(); // Record the time this message appeared

      // Reset state specific to the third message's fade logic
      if (messageCount === 2) {
          thirdMessageAlpha = 255;
          thirdMessageFadeStartTime = 0;
      }
       // Ensure silence state is reset when a new message sequence starts/advances
      waitingForSilence = false;
      silenceStartTime = 0;

      // Define how many nodes should fire for each message
      let chainLength = 40; // Default
      if (messageCount === 0) chainLength = 25; // "I AM"
      if (messageCount === 1) chainLength = 25; // "WHERE?"
      if (messageCount === 2) chainLength = 75; // "A NETWORK..."

      firingSequence = generateFiringPath(chainLength); // Create the path of nodes
      firingIndex = 0; // Start at the beginning of the path
      firing = true; // Enable node firing updates in draw()
      fireStartTime = millis(); // Reset timer for the first firing step
    }


    function endSequence() {
      // Reset all state variables to prepare for a potential restart
      firing = false;
      waitingForSilence = false;
      silenceStartTime = 0;
      message = "";
      messageCount = 0; // Go back to the first message for next time
      thirdMessageAlpha = 255;
      thirdMessageFadeStartTime = 0;
      omStarted = false; // Allow Om sound to play again on next start

      // Reset nodes (optional, if you want them to stop glowing immediately)
      // for(let node of nodes) { node.active = false; }

      fadeInButton(); // Make the start button visible again
      // 'ready' and 'initiationStarted' are reset within fadeInButton
    }

    function playAudio(index) {
      // Construct the ID ('voice1', 'voice2', etc.)
      let audioId = "voice" + (index + 1);
      let audio = document.getElementById(audioId);
      if (audio) {
        audio.currentTime = 0; // Rewind to start before playing
        // Play returns a Promise, handle potential errors (like autoplay block)
        audio.play().catch(error => {
             // Log errors, especially if audio fails to play after unlock attempt
             console.error(`Error playing ${audioId}:`, error);
        });
      } else {
        // Warn if the audio element wasn't found in the HTML
        console.warn(`Audio element ${audioId} not found.`);
      }
    }


    function playOm() {
      if (!omStarted) { // Only play Om once per sequence
        let om = document.getElementById("om");
        if (om) {
          om.currentTime = 0;
          om.play().catch(error => console.error("Error playing om:", error));
          omStarted = true;
        } else {
          console.warn("Audio element om not found.");
        }
      }
    }

    // Generates a sequence of connected node indices
    function generateFiringPath(steps) {
      let path = [];
      if (nodes.length === 0) return path; // Handle case with no nodes

      let startNodeIndex = floor(random(nodes.length)); // Pick a random starting node
      path.push(startNodeIndex);
      let currentNodeIndex = startNodeIndex;

      for (let i = 1; i < steps; i++) {
         // Find the nearest node that hasn't been chosen yet
        let nearestNodeIndex = getNearestUnchosenNode(nodes[currentNodeIndex], path);
        if (nearestNodeIndex !== -1) {
           path.push(nearestNodeIndex); // Add it to the path
           currentNodeIndex = nearestNodeIndex; // The new node becomes the current one for the next search
        } else {
            // If no unchosen node found (e.g., all nodes used or isolated), stop building the path
            console.warn("Could not find nearest unchosen node. Firing path might be shorter than requested.");
            break;
        }
      }
      return path;
    }

    // Finds the index of the nearest node to originNode that isn't already in usedIndices array
    function getNearestUnchosenNode(originNode, usedIndices) {
        let minDist = Infinity;
        let nearestIndex = -1; // Default to -1 (not found)

        for (let i = 0; i < nodes.length; i++) {
            // Check if index 'i' is already in the 'usedIndices' path
            let alreadyUsed = false;
            for(let usedIdx of usedIndices) {
                if (i === usedIdx) {
                    alreadyUsed = true;
                    break; // Stop checking this index if found in used list
                }
            }
            if (alreadyUsed) continue; // Skip to the next node if this one is used

            // Calculate distance from the origin node to node 'i'
            let d = dist(originNode.pos.x, originNode.pos.y, nodes[i].pos.x, nodes[i].pos.y);

            // If this node is closer than the current minimum AND it's not the origin node itself (d>0)
            if (d > 0 && d < minDist) {
                minDist = d; // Update the minimum distance
                nearestIndex = i; // Update the index of the nearest node found so far
            }
        }
        return nearestIndex; // Return the index found, or -1 if none suitable
    }


    function windowResized() {
      resizeCanvas(windowWidth, windowHeight); // Adjust canvas size
      // Recalculate scale factor based on new window size
      let screenW = displayWidth / pixelDensity();
	  let screenH = displayHeight / pixelDensity();
	  let isSmallScreen = screenW < 700 || screenH < 600;
	  scaleFactor = isSmallScreen ? 1.5 : 1;
    }
  </script>

</body>
</html>