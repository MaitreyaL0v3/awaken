
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>I AM WHERE</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #0d0d0d;
      font-family: monospace;
      color: white;
    }

    #startButton {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px 50px;
      font-size: 26px;
      background: none;
      border: 2px solid white;
      color: white;
      cursor: pointer;
      z-index: 10;
      transition: opacity 1s ease, transform 0.5s ease, box-shadow 0.5s ease;
      animation: pulse 3s infinite;
    }

    #startButton:hover {
      background: white;
      color: black;
      transform: translate(-50%, -50%) scale(1.05);
      box-shadow: 0 0 15px white;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 5px white; }
      50% { box-shadow: 0 0 25px white; }
      100% { box-shadow: 0 0 5px white; }
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      display: block;
    }
  </style>
</head>
<body>
  <button id="startButton">AWAKEN YOURSELF</button>

  <!-- Load p5.js -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.4.2/lib/p5.min.js"></script>

  <!-- Audio -->
  <audio id="voice1" src="voice1.mp3"></audio>
  <audio id="voice2" src="voice2.mp3"></audio>
  <audio id="voice3" src="voice3.mp3"></audio>
  <audio id="om" src="om.mp3"></audio>

  <script>
    let nodes = [];
    let firingSequence = [];
    let firingIndex = 0;
    let message = "";
    let messages = ["I AM", "WHERE?", "A NETWORK, NOT AN INDIVIDUAL"];
    let messageCount = 0;
    let messageTimer = 0;
    let firing = false;
    let ready = true;
    let button;
    let fireStartTime = 0;
    let initiationStarted = false;
    let omStarted = false;
	let messageAlpha = 255;
	let fadeStartTime = 0;
	let fadingMessage = false;
	let scaleFactor = 1;

    function setup() {
      createCanvas(windowWidth, windowHeight);

	  let screenW = displayWidth / pixelDensity();
	  let screenH = displayHeight / pixelDensity();
	  let isSmallScreen = screenW < 700 || screenH < 600;
	  scaleFactor = isSmallScreen ? 1.5 : 1;
      for (let i = 0; i < 250; i++) {
        nodes.push({
          pos: createVector(random(width), random(height)),
          vel: createVector(random(-0.3, 0.3), random(-0.3, 0.3)),
          active: false,
          lastFired: 0
        });
      }

      button = document.getElementById("startButton");
      button.addEventListener("click", () => {
        if (ready && !initiationStarted) {
          initiationStarted = true;
          fadeOutButton();
          setTimeout(() => {
            playOm();
            setTimeout(() => {
              messageCount = 0;
              triggerNextMessage();
            }, 3000); // wait after Om starts
          }, 3000); // wait before Om starts
        }
      });
    }

function draw() {
  background(13);

  for (let node of nodes) {
    node.pos.add(node.vel);
    if (node.pos.x < 0 || node.pos.x > width) node.vel.x *= -1;
    if (node.pos.y < 0 || node.pos.y > height) node.vel.y *= -1;
  }

  for (let i = 0; i < nodes.length; i++) {
    for (let j = i + 1; j < nodes.length; j++) {
      let d = dist(nodes[i].pos.x, nodes[i].pos.y, nodes[j].pos.x, nodes[j].pos.y);
      if (d < 90) {
        stroke(100, 150, 255, map(d, 0, 90, 180, 0));
        strokeWeight(map(d, 0, 90, 1.5, 0.1));
        line(nodes[i].pos.x, nodes[i].pos.y, nodes[j].pos.x, nodes[j].pos.y);
      }
    }
  }

  if (firing && firingIndex < firingSequence.length) {
    if (millis() - fireStartTime > 40) {
      let currentNode = firingSequence[firingIndex];
      nodes[currentNode].active = true;
      nodes[currentNode].lastFired = millis();
      firingIndex++;
      fireStartTime = millis();
    }
  }

  for (let node of nodes) {
    if (node.active && millis() - node.lastFired > 400) {
      node.active = false;
    }
  }

  noStroke();
  for (let node of nodes) {
    if (node.active) {
      fill(255, 255, 150);
      ellipse(node.pos.x, node.pos.y, 10 * scaleFactor, 10 * scaleFactor);
    } else {
      fill(180, 200, 255);
      ellipse(node.pos.x, node.pos.y, 4 * scaleFactor, 4 * scaleFactor);
    }
  }

  // Show message normally or fading
  if (message !== "") {
    fill(255, messageAlpha);
    textAlign(CENTER, CENTER);
    textSize(42 * scaleFactor);
    text(message, width / 2, height / 2);
  }

  if (firing && firingIndex >= firingSequence.length && millis() - messageTimer > 2000) {
    messageCount++;
    if (messageCount < messages.length) {
      triggerNextMessage();
    } else {
      // Begin final fade
      if (!fadingMessage) {
        fadingMessage = true;
        fadeStartTime = millis();
      } else {
        let elapsed = millis() - fadeStartTime;
        if (elapsed > 4000 && elapsed <= 6000) {
          messageAlpha = map(elapsed, 4000, 6000, 255, 0);
        } else if (elapsed > 6000) {
          endSequence();
        }
      }
    }
  }
}

    function fadeOutButton() {
      ready = false;
      button.style.transition = "opacity 1s ease";
      button.style.opacity = 0;
      setTimeout(() => {
        button.style.display = "none";
      }, 1000);
    }

    function fadeInButton() {
      button.style.display = "block";
      setTimeout(() => {
        button.style.opacity = 1;
        initiationStarted = false;
      }, 50);
    }

	function triggerNextMessage() {
	  message = messages[messageCount];
	  playAudio(messageCount);

	  // Define chain lengths per message
	  let chainLength = 40;
	  if (messageCount === 0) chainLength = 25;
	  if (messageCount === 1) chainLength = 25;
	  if (messageCount === 2) chainLength = 75;

	  firingSequence = generateFiringPath(chainLength);
	  firingIndex = 0;
	  firing = true;
	  fireStartTime = millis();
	  messageTimer = millis();
	}


	function endSequence() {
	  firing = false;
	  message = "";
	  messageAlpha = 255;
	  fadingMessage = false;
	  ready = true;
	  fadeInButton();
	  omStarted = false;
	}

    function playAudio(index) {
      let audio = document.getElementById("voice" + (index + 1));
      if (audio) {
        audio.currentTime = 0;
        audio.play();
      }
    }

    function playOm() {
      if (!omStarted) {
        let om = document.getElementById("om");
        if (om) {
          om.currentTime = 0;
          om.play();
          omStarted = true;
        }
      }
    }

    function generateFiringPath(steps) {
      let path = [];
      let start = floor(random(nodes.length));
      path.push(start);
      for (let i = 1; i < steps; i++) {
        let nearest = getNearestUnchosenNode(nodes[path[i - 1]], path);
        if (nearest !== -1) path.push(nearest);
        else break;
      }
      return path;
    }

    function getNearestUnchosenNode(originNode, used) {
      let minDist = Infinity;
      let nearestIndex = -1;
      for (let i = 0; i < nodes.length; i++) {
        if (used.includes(i)) continue;
        let d = dist(originNode.pos.x, originNode.pos.y, nodes[i].pos.x, nodes[i].pos.y);
        if (d < minDist) {
          minDist = d;
          nearestIndex = i;
        }
      }
      return nearestIndex;
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>

</body>
</html>
